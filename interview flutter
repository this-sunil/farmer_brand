ðŸš€ Flutter Interview Series â€” Day 1

ðŸ“Œ Q1: What is Flutter?
Flutter is Googleâ€™s open-source UI toolkit for building cross-platform apps (Android, iOS, Web, Desktop) from a single codebase using Dart. It provides its own rendering engine for consistent UI across platforms.

ðŸ“Œ Q2: What is Dart and why Flutter uses it?
Dart is a client-optimized language. Flutter uses it for Ahead-of-Time (AOT) compilation (fast production apps) and Just-in-Time (JIT) compilation (fast development with Hot Reload).

ðŸ“Œ Q3: What are Widgets in Flutter?
Widgets are the basic building blocks of UI. Everything in Flutter is a widget â€” text, buttons, layout containers, etc.

ðŸ“Œ Q4: Difference between StatelessWidget and StatefulWidget

StatelessWidget â†’ UI is immutable
StatefulWidget â†’ UI changes dynamically with setState() or state management.

ðŸ“Œ Q5: What is Hot Reload?
Updates the running app instantly without losing the current state, speeding up UI development.

Q6:What is use of solid principle?

The SOLID acronym stands for:

S -> Single Responsibility Principle
O -> Open/Closed Principle
L -> Liskov Substitution Principle
I -> Interface Segregation Principle
D -> Dependency Inversion Principle

- The Single Responsibility Principle (SRP) states that a class should have only one reason to change. In other words, it should have a single, well-defined responsibility or task within a software system.

- The Open/Closed Principle (OCP) states that software entities, such as classes, should be open for extension but closed for modification. This means you can add new functionality without altering existing code.

- The Liskov Substitution Principle (LSP) states that objects of a derived class should be able to replace objects of the base class without affecting the correctness of the program. 

- The Interface Segregation Principle (ISP) emphasizes that classes or components that use interfaces should not be forced to depend on interfaces they don't use. 

- The Dependency Inversion Principle (DIP) states that high-level modules (or classes) should not depend on low-level modules; both should depend on abstractions, such as interfaces.